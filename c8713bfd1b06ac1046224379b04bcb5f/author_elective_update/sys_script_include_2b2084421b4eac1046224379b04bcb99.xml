<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="DELETE">
        <access>public</access>
        <active>true</active>
        <api_name>x_usbna_bs.BitSightImportReportProcessor</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Process externally facing website vulnerabilities</description>
        <name>BitSightImportReportProcessor</name>
        <script><![CDATA[var BitSightImportReportProcessor = Class.create();
BitSightImportReportProcessor.prototype = {

    initialize: function() {},
    /*****************************************************************************************
          GSLog capability to log error, info etc
          call example: var l = this._logger();
          more info: /kb_view.do?sysparm_article=KB0193916
    **************************************************************/
    _logger: function() {
        var l = new global.GSLog("sn_vul.usb.logging.verbosity", "BitSightImportReportProcessor");
        return l;
    },
    /*****************************************************************************************
    @param1 - Data Source
	Function loads Bit Sight raw risk vector data into their corresponding import set tables.
    ******************************************************************************************/
    importAtt: function(dataSource) {

        var l = this._logger();
        var start = new GlideDateTime();

        var agr = new GlideRecord('sys_attachment');
        agr.addQuery('table_sys_id', dataSource.sys_id);
        var deleteCount = 0;
        agr.query();
        while (agr.next()) {
            try {
                // Process data source file
                var loader = new GlideImportSetLoader();
                var importSetRec = loader.getImportSetGr(dataSource);
                var ranload = loader.loadImportSetTable(importSetRec, dataSource);
                importSetRec.state = "loaded";
                importSetRec.update();
                agr.deleteRecord();
                deleteCount++;
            } catch (e) {
                err_msg = e.message;
            }
        }

        var end = new GlideDateTime();
        var timeElapsed = end.getNumericValue() - start.getNumericValue();
        l.logInfo(gs.getMessage('sn_vul', "BitSight Load Data <Time Elapsed> " + timeElapsed));
    },
    /*****************************************************************************************
    @param1 - Attachement ID, Risk Vector, Action
	Function routes the task to the appropriate risk vector process.
    ******************************************************************************************/
    processReport: function(attachmentId, bsSource) {
        var l = this._logger();
        var start = new GlideDateTime();

        switch (bsSource) {
            case "open_ports":
                this._processOPENPORTS(attachmentId);
                break;
            case "ssl_certs":
                this._processSSLCS(attachmentId);
                break;
            case "ssl_conf":
                this._processSSLCF(attachmentId);
                break;
            case "app_sec":
                this._processAPPSEC(attachmentId);
                break;
            default:
                break;
        }
        var end = new GlideDateTime();
        var timeElapsed = end.getNumericValue() - start.getNumericValue();
        l.logInfo(gs.getMessage('sn_vul', "BitSight Process Report: " + bsSource + " <Time Elapsed> " + timeElapsed));
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the SSL Certficates risk vector process.
    ******************************************************************************************/
    _processSSLCS: function(attachmentId) {

        var l = this._logger();
        var viOBJ;
        var viObjAR = [];
        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" && x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;
                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    viOBJ["summary"] = DilAnnot.message;

                                    for (var f in DilAnnot) {
                                        if (f == "certchain") {
                                            var CrtChain = DilAnnot[f];
                                            for (r = 0; r < CrtChain.length; r++) {
                                                workNotes += "DnsName: " + CrtChain[r].dnsName + "\n" + "Issuer: " +
                                                    CrtChain[r].issuerName + "\n" + "Srl#: " + CrtChain[r].serialNumber + "\n" +
                                                    "Key Algorithm: " + CrtChain[r].keyAlgorithm + "\n" +
                                                    "Key Length: " + CrtChain[r].keyLength + "\n" +
                                                    "Sig Algorithm: " + CrtChain[r].signatureAlgorithm + "\n" +
                                                    "Start Date: " + CrtChain[r].startDate + "\n" + "End Date: " + CrtChain[r].endDate + "\n" +
                                                    "Subj Name: " + CrtChain[r].subjectName;
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                            viOBJ["evidence_key"] = TY[y].evidence_key;
                        }
                    }
                    viOBJ["risk_score"] = riskScore;
                    viOBJ["first_seen"] = firstSeen;
                    viOBJ["last_seen"] = lastSeen;
                    viOBJ["worknotes"] = workNotes;
                    viOBJ["source"] = "BS-SSLCS";
                    viObjAR.push(viOBJ);
                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-SSLCS Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the Web Application Header risk vector process.
    ******************************************************************************************/
    _processAPPSEC: function(attachmentId) {

        var l = this._logger();
        var viOBJ = {};
        var viObjAR = [];
        var AnnotArr = {};
        var AnnotObj = [];

        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" && x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];

                        for (var y in TY) {
                            var workNotes, annotCount;
                            AnnotArr = [];

                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") {
                                    riskScore = this._deriveScore(Dtls[g]);
                                    l.logInfo(gs.getMessage('sn_vul', "BS-APPSEC SCORE: " + riskScore));
                                }
                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    for (var f in DilAnnot) {
                                        if (f == "required") {
                                            var VulnDtl = DilAnnot[f];
                                            for (r in VulnDtl) {
                                                var Annot = VulnDtl[r].annotations;
                                                annotCount = this._getObjCount(VulnDtl[r].annotations);

                                                for (var i = 0; i < annotCount; i++) {
                                                    AnnotArr[i] = [];
                                                    AnnotArr[i][0] = VulnDtl[r].name;
                                                    AnnotArr[i][1] = Annot[g].message;
                                                    AnnotArr[i][2] = Annot[g].help_text;
                                                    AnnotArr[i][3] = Annot[g].remediation_tip;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                    l.logInfo(gs.getMessage('sn_vul', "BS-APPSEC Remediation: " + viOBJ["resolution"]));
                                }
                            }
                            for (var x = 0; x < annotCount; x++) {

                                viOBJ["evidence_key"] = TY[y].evidence_key;
                                viOBJ["summary"] = AnnotArr[x][0]; // name
                                viOBJ["worknotes"] = "Help Text: " + AnnotArr[x][2] + "\n " + "Message: " + AnnotArr[x][1] +
                                    +"\n " + "Remediation Tip : " + AnnotArr[x][3] + "\n";
                                viOBJ["risk_score"] = riskScore;
                                viOBJ["first_seen"] = firstSeen;
                                viOBJ["last_seen"] = lastSeen;
                                viOBJ["source"] = "BS-APPSEC";
                                viObjAR.push(viOBJ);
                            }
                        }
                    }

                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-APPSEC Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the Open Ports Risk Vector process.
    ******************************************************************************************/
    _processOPENPORTS: function(attachmentId) {

        var l = this._logger();
        var viOBJ = {};
        var viObjAR = [];
        var AnnotArr = {};
        var AnnotObj = [];

        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" && x == "results") {
                        var veKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;

                            var Dtls = TY[y].details;
                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    for (var r in DilAnnot) {
                                        workNotes += "Status: " + DilAnnot[r].Status + "\n" + "Product: " +
                                            DilAnnot[r].Product + "\n" + "Title: " + DilAnnot[r].Title + "\n" +
                                            "CPE: " + DilAnnot[r].CPE + "\n" + "Server: " + DilAnnot[r].Server + "\n" +
                                            "Location: " + DilAnnot[r].Location + "\n";
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Message : " + Remed[0].message + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                        }
                        viOBJ["summary"] = 'Open Ports';
                        viOBJ["risk_score"] = riskScore;
                        viOBJ["first_seen"] = firstSeen;
                        viOBJ["last_seen"] = lastSeen;
                        viOBJ["worknotes"] = workNotes;
                        viOBJ["source"] = "BS-OPENPORTS";
                        viObjAR.push(viOBJ);
                    }
                }
            }
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-OPENPORTS Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the SSL Configuration risk vector process.
    ******************************************************************************************/
    _processSSLCF: function(attachmentId) {

        var l = this._logger();
        var viOBJ;
        var viObjAR = [];
        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" && x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;
                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    viOBJ["summary"] = DilAnnot.message;

                                    for (var f in DilAnnot) {
                                        if (f == "certchain") {
                                            var CrtChain = DilAnnot[f];
                                            for (r = 0; r < CrtChain.length; r++) {
                                                workNotes += "DnsName: " + CrtChain[r].dnsName + "\n" + "Issuer: " +
                                                    CrtChain[r].issuerName + "\n" +
                                                    "Srl#: " + CrtChain[r].serialNumber + "\n" +
                                                    "Key Algorithm: " + CrtChain[r].keyAlgorithm + "\n" +
                                                    "Key Length: " + CrtChain[r].keyLength + "\n" +
                                                    "Sig Algorithm: " + CrtChain[r].signatureAlgorithm + "\n" +
                                                    "Start Date: " + CrtChain[r].startDate + "\n" +
                                                    "End Date: " + CrtChain[r].endDate + "\n" +
                                                    "Subj Name: " + CrtChain[r].subjectName;
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                            viOBJ["evidence_key"] = TY[y].evidence_key;
                        }
                    }
                    viOBJ["risk_score"] = riskScore;
                    viOBJ["first_seen"] = firstSeen;
                    viOBJ["last_seen"] = lastSeen;
                    viOBJ["worknotes"] = workNotes;
                    viOBJ["source"] = "BS-SSLCF";
                    viObjAR.push(viOBJ);
                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-SSLCS Error: " + ex));
        }
    },
    /*****************************************************
    @param1 - Vuln Buffer Object
    ******************************************************/
    _insertCore: function(VulnObj) {
        var veID, veKey, pLabel;

        for (var idx in VulnObj) {
            var l = this._logger();
            var grVE_1 = new GlideRecord('sn_vul_third_party_entry');
            var grVE_2 = new GlideRecord('sn_vul_third_party_entry');

            try {
                grVE_1.addQuery("summary", VulnObj[idx].summary);
                grVE_1.query();
                if (grVE_1.hasNext()) {
                    pLabel = " Update ";
                    while (grVE_1.next()) {
                        grVE_1.setValue("remediation_notes", VulnObj[idx].resolution);
                        grVE_2.update();
                        veKey = grVE_1.getUniqueValue();
                    }
                } else {
                    pLabel = " Insert ";
                    veID = this._deriveID(VulnObj[idx].summary);
                    if (veID == -1) return -1;

                    grVE_2.setValue("summary", VulnObj[idx].summary);
                    grVE_2.setValue("id", veID);
                    grVE_2.setValue("remediation_notes", VulnObj[idx].resolution);
                    grVE_2.setValue("source", VulnObj[idx].source);
                    grVE_2.insert();
                    veKey = grVE_2.getUniqueValue();
                }
            } catch (ex) {
                l.logError(gs.getMessage('sn_vul', "Insert 3rd Prty Entry Error : " + pLabel + " : " + ex));
            }
            this._insertVI(VulnObj, veKey);
        }
    },
    /*****************************************************
    @param1 - Vuln Buffer Object
	@param2 - Third Party Entry Key
    returns sys_id of the VI
    ******************************************************/
    _insertVI: function(pObj, pVEkey) {
        var pLabel;
        var l = this._logger();
        var grVI_1 = new GlideRecord('sn_vul_ext_vulnerable_item');
        var grVI_2 = new GlideRecord('sn_vul_ext_vulnerable_item');
        for (var i in pObj) {
            try {
                l.logError(gs.getMessage('sn_vul', pObj[i].source + " < Resolution > " + pObj[i].resolution));

                grVI_1.addEncodedQuery("cmdb_ci=" + pObj[i].ciKey + "^vulnerability=" + pObj[i].viKey);
                grVI_1.query();
                if (grVI_1.hasNext()) {
                    pLabel = " Update ";
                    grVI_1.setValue("cmdb_ci", pObj[i].ciKey);
                    grVI_1.setValue("vulnerability", pVEkey);
                    grVI_1.setValue("worknotes", pObj[i].worknotes);
                    grVI_1.setValue("first_seen", pObj[i].first_seen);
                    grVI_1.setValue("last_seen", pObj[i].last_seen);
                    grVI_1.update();
                } else {
                    pLabel = " Insert ";
                    ciKey = this._lookupCI(pObj[i].evidence_key);
                    if (ciKey == -1) {
                        l.logError(gs.getMessage('sn_vul', pObj[i].source + " No CI Found for " + pLabel + " : " + pObj[i].evidence_key));
                        continue;
                    }

                    grVI_2.setValue("cmdb_ci", ciKey);
                    grVI_2.setValue("vulnerability", pVEkey);
                    grVI_2.setValue("worknotes", pObj[i].worknotes);
                    grVI_2.setValue("first_seen", pObj[i].first_seen);
                    grVI_2.setValue("last_seen", pObj[i].last_seen);
                    grVI_2.setValue("source", pObj[i].source);
                    grVI_2.insert();
                }
            } catch (ex) {
                l.logError(gs.getMessage('sn_vul', pObj[i].source + " Create VI : " + ex));
            }
        }
    },
    /**********************************************
    @param1 - Asset Name
    returns sys_id of the CI
    ***********************************************/
    _lookupCI: function(ciName) {

        var grCI = new GlideRecord('cmdb_ci');
        grCI.addEncodedQuery("name=" + ciName + "^u_internet_facingINTrue");
        grCI.setLimit(1);
        grCI.query();
        while (grCI.next()) {
            return grCI.sys_id;
        }
        return -1;
    },
    /**********************************************
    @param1 - Asset Name
    returns sys_id of the CI
    ***********************************************/
    _deriveScore: function(vSeverity) {

        switch (vSeverity) {
            case "BAD":
                return 85;
            case "WARN":
                return 71;
            case "NEUTRAL":
                return 41;
            default:
                return 0;
        }
    },
    /*****************************************************************************************
    @param1 - Action
	Function derives the id for a given vulnerability if the action is INSERT or retrieves
	the sys_id of the existing vulnerability if the action is UPDATE.
    ******************************************************************************************/
    _deriveID: function() {

        var u;
        var n = 1000;
        var t = new GlideRecord('sn_vul_third_party_entry');
        t.addEncodedQuery('idSTARTSWITHBS-');
        t.orderByDesc('u_id_int');
        t.setLimit(1);
        t.query();
        if (t.next()) {
            n = parseInt(t.getValue('u_id_int'));
            n++;
        }
        return 'BS-' + n;
    },
    /*****************************************************************************************
    @param1 - Json Array
	Function computes the number of embedded objects in a JSON array and returns the count.
    ******************************************************************************************/

    _getObjCount: function(array) {

        var count = {};
        array.forEach(function(a) {
            count[a.annotations] = (count[a.annotations] || 0) + 1;
        });

        return Object.keys(count).map(function(k) {
            return count[k];
        });
    },
    type: 'BitSightImportReportProcessor',
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>vxsrin2</sys_created_by>
        <sys_created_on>2021-02-01 18:35:49</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>2b2084421b4eac1046224379b04bcb99</sys_id>
        <sys_mod_count>1</sys_mod_count>
        <sys_name>BitSightImportReportProcessor</sys_name>
        <sys_package display_value="BitSight" source="x_usbna_bs">c8713bfd1b06ac1046224379b04bcb5f</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="BitSight">c8713bfd1b06ac1046224379b04bcb5f</sys_scope>
        <sys_update_name>sys_script_include_2b2084421b4eac1046224379b04bcb99</sys_update_name>
        <sys_updated_by>vxsrin2</sys_updated_by>
        <sys_updated_on>2021-02-02 15:12:45</sys_updated_on>
    </sys_script_include>
    <sys_update_version action="INSERT_OR_UPDATE">
        <action>DELETE</action>
        <application display_value="BitSight">c8713bfd1b06ac1046224379b04bcb5f</application>
        <file_path/>
        <instance_id>15d757e6db004c144d2bac44d4961979</instance_id>
        <instance_name>itsmnowiss</instance_name>
        <name>sys_script_include_2b2084421b4eac1046224379b04bcb99</name>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;&lt;sys_script_include action="INSERT_OR_UPDATE"&gt;&lt;access&gt;public&lt;/access&gt;&lt;active&gt;true&lt;/active&gt;&lt;api_name&gt;x_usbna_bs.BitSightImportReportProcessor&lt;/api_name&gt;&lt;caller_access/&gt;&lt;client_callable&gt;false&lt;/client_callable&gt;&lt;description&gt;Process externally facing website vulnerabilities&lt;/description&gt;&lt;name&gt;BitSightImportReportProcessor&lt;/name&gt;&lt;script&gt;&lt;![CDATA[var BitSightImportReportProcessor = Class.create();
BitSightImportReportProcessor.prototype = {

    initialize: function() {},
    /*****************************************************************************************
          GSLog capability to log error, info etc
          call example: var l = this._logger();
          more info: /kb_view.do?sysparm_article=KB0193916
    **************************************************************/
    _logger: function() {
        var l = new global.GSLog("sn_vul.usb.logging.verbosity", "BitSightImportReportProcessor");
        return l;
    },
    /*****************************************************************************************
    @param1 - Data Source
	Function loads Bit Sight raw risk vector data into their corresponding import set tables.
    ******************************************************************************************/
    importAtt: function(dataSource) {

        var l = this._logger();
        var start = new GlideDateTime();

        var agr = new GlideRecord('sys_attachment');
        agr.addQuery('table_sys_id', dataSource.sys_id);
        var deleteCount = 0;
        agr.query();
        while (agr.next()) {
            try {
                // Process data source file
                var loader = new GlideImportSetLoader();
                var importSetRec = loader.getImportSetGr(dataSource);
                var ranload = loader.loadImportSetTable(importSetRec, dataSource);
                importSetRec.state = "loaded";
                importSetRec.update();
                agr.deleteRecord();
                deleteCount++;
            } catch (e) {
                err_msg = e.message;
            }
        }

        var end = new GlideDateTime();
        var timeElapsed = end.getNumericValue() - start.getNumericValue();
        l.logInfo(gs.getMessage('sn_vul', "BitSight Load Data &lt;Time Elapsed&gt; " + timeElapsed));
    },
    /*****************************************************************************************
    @param1 - Attachement ID, Risk Vector, Action
	Function routes the task to the appropriate risk vector process.
    ******************************************************************************************/
    processReport: function(attachmentId, bsSource) {
        var l = this._logger();
        var start = new GlideDateTime();

        switch (bsSource) {
            case "open_ports":
                this._processOPENPORTS(attachmentId);
                break;
            case "ssl_certs":
                this._processSSLCS(attachmentId);
                break;
            case "ssl_conf":
                this._processSSLCF(attachmentId);
                break;
            case "app_sec":
                this._processAPPSEC(attachmentId);
                break;
            default:
                break;
        }
        var end = new GlideDateTime();
        var timeElapsed = end.getNumericValue() - start.getNumericValue();
        l.logInfo(gs.getMessage('sn_vul', "BitSight Process Report: " + bsSource + " &lt;Time Elapsed&gt; " + timeElapsed));
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the SSL Certficates risk vector process.
    ******************************************************************************************/
    _processSSLCS: function(attachmentId) {

        var l = this._logger();
        var viOBJ;
        var viObjAR = [];
        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" &amp;&amp; x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;
                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    viOBJ["summary"] = DilAnnot.message;

                                    for (var f in DilAnnot) {
                                        if (f == "certchain") {
                                            var CrtChain = DilAnnot[f];
                                            for (r = 0; r &lt; CrtChain.length; r++) {
                                                workNotes += "DnsName: " + CrtChain[r].dnsName + "\n" + "Issuer: " +
                                                    CrtChain[r].issuerName + "\n" + "Srl#: " + CrtChain[r].serialNumber + "\n" +
                                                    "Key Algorithm: " + CrtChain[r].keyAlgorithm + "\n" +
                                                    "Key Length: " + CrtChain[r].keyLength + "\n" +
                                                    "Sig Algorithm: " + CrtChain[r].signatureAlgorithm + "\n" +
                                                    "Start Date: " + CrtChain[r].startDate + "\n" + "End Date: " + CrtChain[r].endDate + "\n" +
                                                    "Subj Name: " + CrtChain[r].subjectName;
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                            viOBJ["evidence_key"] = TY[y].evidence_key;
                        }
                    }
                    viOBJ["risk_score"] = riskScore;
                    viOBJ["first_seen"] = firstSeen;
                    viOBJ["last_seen"] = lastSeen;
                    viOBJ["worknotes"] = workNotes;
                    viOBJ["source"] = "BS-SSLCS";
                    viObjAR.push(viOBJ);
                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-SSLCS Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the Web Application Header risk vector process.
    ******************************************************************************************/
    _processAPPSEC: function(attachmentId) {

        var l = this._logger();
        var viOBJ = {};
        var viObjAR = [];
        var AnnotArr = {};
        var AnnotObj = [];

        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" &amp;&amp; x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];

                        for (var y in TY) {
                            var workNotes, annotCount;
                            AnnotArr = [];

                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") {
                                    riskScore = this._deriveScore(Dtls[g]);
                                    l.logInfo(gs.getMessage('sn_vul', "BS-APPSEC SCORE: " + riskScore));
                                }
                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    for (var f in DilAnnot) {
                                        if (f == "required") {
                                            var VulnDtl = DilAnnot[f];
                                            for (r in VulnDtl) {
                                                var Annot = VulnDtl[r].annotations;
                                                annotCount = this._getObjCount(VulnDtl[r].annotations);

                                                for (var i = 0; i &lt; annotCount; i++) {
                                                    AnnotArr[i] = [];
                                                    AnnotArr[i][0] = VulnDtl[r].name;
                                                    AnnotArr[i][1] = Annot[g].message;
                                                    AnnotArr[i][2] = Annot[g].help_text;
                                                    AnnotArr[i][3] = Annot[g].remediation_tip;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                    l.logInfo(gs.getMessage('sn_vul', "BS-APPSEC Remediation: " + viOBJ["resolution"]));
                                }
                            }
                            for (var x = 0; x &lt; annotCount; x++) {

                                viOBJ["evidence_key"] = TY[y].evidence_key;
                                viOBJ["summary"] = AnnotArr[x][0]; // name
                                viOBJ["worknotes"] = "Help Text: " + AnnotArr[x][2] + "\n " + "Message: " + AnnotArr[x][1] +
                                    +"\n " + "Remediation Tip : " + AnnotArr[x][3] + "\n";
                                viOBJ["risk_score"] = riskScore;
                                viOBJ["first_seen"] = firstSeen;
                                viOBJ["last_seen"] = lastSeen;
                                viOBJ["source"] = "BS-APPSEC";
                                viObjAR.push(viOBJ);
                            }
                        }
                    }

                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-APPSEC Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the Open Ports Risk Vector process.
    ******************************************************************************************/
    _processOPENPORTS: function(attachmentId) {

        var l = this._logger();
        var viOBJ = {};
        var viObjAR = [];
        var AnnotArr = {};
        var AnnotObj = [];

        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" &amp;&amp; x == "results") {
                        var veKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;

                            var Dtls = TY[y].details;
                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    for (var r in DilAnnot) {
                                        workNotes += "Status: " + DilAnnot[r].Status + "\n" + "Product: " +
                                            DilAnnot[r].Product + "\n" + "Title: " + DilAnnot[r].Title + "\n" +
                                            "CPE: " + DilAnnot[r].CPE + "\n" + "Server: " + DilAnnot[r].Server + "\n" +
                                            "Location: " + DilAnnot[r].Location + "\n";
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Message : " + Remed[0].message + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                        }
                        viOBJ["summary"] = 'Open Ports';
                        viOBJ["risk_score"] = riskScore;
                        viOBJ["first_seen"] = firstSeen;
                        viOBJ["last_seen"] = lastSeen;
                        viOBJ["worknotes"] = workNotes;
                        viOBJ["source"] = "BS-OPENPORTS";
                        viObjAR.push(viOBJ);
                    }
                }
            }
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-OPENPORTS Error: " + ex));
        }
    },
    /*****************************************************************************************
    @param1 - Attachement ID
	Function starts the SSL Configuration risk vector process.
    ******************************************************************************************/
    _processSSLCF: function(attachmentId) {

        var l = this._logger();
        var viOBJ;
        var viObjAR = [];
        var attachment = new GlideSysAttachment();
        var stream = attachment.getContentStream(attachmentId);
        var reader = new GlideTextReader(stream);
        var ln = ' ';
        try {
            while ((ln = reader.readLine()) != null) {
                viOBJ = {};
                var record = JSON.parse(ln);
                for (x in record) {

                    if ((typeof record[x]) == "object" &amp;&amp; x == "results") {
                        var viKey, ciKey, firstSeen, lastSeen, riskScore;
                        var TY = record[x];
                        for (var y in TY) {
                            var workNotes;
                            var Dtls = TY[y].details;

                            first_seen = TY[y].first_seen;
                            last_seen = TY[y].last_seen;
                            for (var g in Dtls) {
                                if (g == "grade") riskScore = this._deriveScore(Dtls[g]);

                                if (g == "diligence_annotations") {
                                    var DilAnnot = Dtls[g];
                                    viOBJ["summary"] = DilAnnot.message;

                                    for (var f in DilAnnot) {
                                        if (f == "certchain") {
                                            var CrtChain = DilAnnot[f];
                                            for (r = 0; r &lt; CrtChain.length; r++) {
                                                workNotes += "DnsName: " + CrtChain[r].dnsName + "\n" + "Issuer: " +
                                                    CrtChain[r].issuerName + "\n" +
                                                    "Srl#: " + CrtChain[r].serialNumber + "\n" +
                                                    "Key Algorithm: " + CrtChain[r].keyAlgorithm + "\n" +
                                                    "Key Length: " + CrtChain[r].keyLength + "\n" +
                                                    "Sig Algorithm: " + CrtChain[r].signatureAlgorithm + "\n" +
                                                    "Start Date: " + CrtChain[r].startDate + "\n" +
                                                    "End Date: " + CrtChain[r].endDate + "\n" +
                                                    "Subj Name: " + CrtChain[r].subjectName;
                                            }
                                        }
                                    }
                                }
                                if (g == "remediations") {
                                    var Remed = Dtls[g];
                                    viOBJ["resolution"] = "Help Text: " + Remed[0].help_text + "\n " +
                                        "Remediation Tip : " + Remed[0].remediation_tip + "\n";
                                }
                            }
                            viOBJ["evidence_key"] = TY[y].evidence_key;
                        }
                    }
                    viOBJ["risk_score"] = riskScore;
                    viOBJ["first_seen"] = firstSeen;
                    viOBJ["last_seen"] = lastSeen;
                    viOBJ["worknotes"] = workNotes;
                    viOBJ["source"] = "BS-SSLCF";
                    viObjAR.push(viOBJ);
                }
            }
            /******************************  Create Core Table Entries ************************************/
            this._insertCore(viObjAR);
        } catch (ex) {
            l.logError(gs.getMessage('sn_vul', "BS-SSLCS Error: " + ex));
        }
    },
    /*****************************************************
    @param1 - Vuln Buffer Object
    ******************************************************/
    _insertCore: function(VulnObj) {
        var veID, veKey, pLabel;

        for (var idx in VulnObj) {
            var l = this._logger();
            var grVE_1 = new GlideRecord('sn_vul_third_party_entry');
            var grVE_2 = new GlideRecord('sn_vul_third_party_entry');

            try {
                grVE_1.addQuery("summary", VulnObj[idx].summary);
                grVE_1.query();
                if (grVE_1.hasNext()) {
                    pLabel = " Update ";
                    while (grVE_1.next()) {
                        grVE_1.setValue("remediation_notes", VulnObj[idx].resolution);
                        grVE_2.update();
                        veKey = grVE_1.getUniqueValue();
                    }
                } else {
                    pLabel = " Insert ";
                    veID = this._deriveID(VulnObj[idx].summary);
                    if (veID == -1) return -1;

                    grVE_2.setValue("summary", VulnObj[idx].summary);
                    grVE_2.setValue("id", veID);
                    grVE_2.setValue("remediation_notes", VulnObj[idx].resolution);
                    grVE_2.setValue("source", VulnObj[idx].source);
                    grVE_2.insert();
                    veKey = grVE_2.getUniqueValue();
                }
            } catch (ex) {
                l.logError(gs.getMessage('sn_vul', "Insert 3rd Prty Entry Error : " + pLabel + " : " + ex));
            }
            this._insertVI(VulnObj, veKey);
        }
    },
    /*****************************************************
    @param1 - Vuln Buffer Object
	@param2 - Third Party Entry Key
    returns sys_id of the VI
    ******************************************************/
    _insertVI: function(pObj, pVEkey) {
        var pLabel;
        var l = this._logger();
        var grVI_1 = new GlideRecord('sn_vul_ext_vulnerable_item');
        var grVI_2 = new GlideRecord('sn_vul_ext_vulnerable_item');
        for (var i in pObj) {
            try {
                l.logError(gs.getMessage('sn_vul', pObj[i].source + " &lt; Resolution &gt; " + pObj[i].resolution));

                grVI_1.addEncodedQuery("cmdb_ci=" + pObj[i].ciKey + "^vulnerability=" + pObj[i].viKey);
                grVI_1.query();
                if (grVI_1.hasNext()) {
                    pLabel = " Update ";
                    grVI_1.setValue("cmdb_ci", pObj[i].ciKey);
                    grVI_1.setValue("vulnerability", pVEkey);
                    grVI_1.setValue("worknotes", pObj[i].worknotes);
                    grVI_1.setValue("first_seen", pObj[i].first_seen);
                    grVI_1.setValue("last_seen", pObj[i].last_seen);
                    grVI_1.update();
                } else {
                    pLabel = " Insert ";
                    ciKey = this._lookupCI(pObj[i].evidence_key);
                    if (ciKey == -1) {
                        l.logError(gs.getMessage('sn_vul', pObj[i].source + " No CI Found for " + pLabel + " : " + pObj[i].evidence_key));
                        continue;
                    }

                    grVI_2.setValue("cmdb_ci", ciKey);
                    grVI_2.setValue("vulnerability", pVEkey);
                    grVI_2.setValue("worknotes", pObj[i].worknotes);
                    grVI_2.setValue("first_seen", pObj[i].first_seen);
                    grVI_2.setValue("last_seen", pObj[i].last_seen);
                    grVI_2.setValue("source", pObj[i].source);
                    grVI_2.insert();
                }
            } catch (ex) {
                l.logError(gs.getMessage('sn_vul', pObj[i].source + " Create VI : " + ex));
            }
        }
    },
    /**********************************************
    @param1 - Asset Name
    returns sys_id of the CI
    ***********************************************/
    _lookupCI: function(ciName) {

        var grCI = new GlideRecord('cmdb_ci');
        grCI.addEncodedQuery("name=" + ciName + "^u_internet_facingINTrue");
        grCI.setLimit(1);
        grCI.query();
        while (grCI.next()) {
            return grCI.sys_id;
        }
        return -1;
    },
    /**********************************************
    @param1 - Asset Name
    returns sys_id of the CI
    ***********************************************/
    _deriveScore: function(vSeverity) {

        switch (vSeverity) {
            case "BAD":
                return 85;
            case "WARN":
                return 71;
            case "NEUTRAL":
                return 41;
            default:
                return 0;
        }
    },
    /*****************************************************************************************
    @param1 - Action
	Function derives the id for a given vulnerability if the action is INSERT or retrieves
	the sys_id of the existing vulnerability if the action is UPDATE.
    ******************************************************************************************/
    _deriveID: function() {

        var u;
        var n = 1000;
        var t = new GlideRecord('sn_vul_third_party_entry');
        t.addEncodedQuery('idSTARTSWITHBS-');
        t.orderByDesc('u_id_int');
        t.setLimit(1);
        t.query();
        if (t.next()) {
            n = parseInt(t.getValue('u_id_int'));
            n++;
        }
        return 'BS-' + n;
    },
    /*****************************************************************************************
    @param1 - Json Array
	Function computes the number of embedded objects in a JSON array and returns the count.
    ******************************************************************************************/

    _getObjCount: function(array) {

        var count = {};
        array.forEach(function(a) {
            count[a.annotations] = (count[a.annotations] || 0) + 1;
        });

        return Object.keys(count).map(function(k) {
            return count[k];
        });
    },
    type: 'BitSightImportReportProcessor',
};]]&gt;&lt;/script&gt;&lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;&lt;sys_created_by&gt;vxsrin2&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2021-02-01 18:35:49&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;false&lt;/sys_customer_update&gt;&lt;sys_id&gt;2b2084421b4eac1046224379b04bcb99&lt;/sys_id&gt;&lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;&lt;sys_name&gt;BitSightImportReportProcessor&lt;/sys_name&gt;&lt;sys_package display_value="BitSight" source="x_usbna_bs"&gt;c8713bfd1b06ac1046224379b04bcb5f&lt;/sys_package&gt;&lt;sys_policy&gt;read&lt;/sys_policy&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="BitSight"&gt;c8713bfd1b06ac1046224379b04bcb5f&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_script_include_2b2084421b4eac1046224379b04bcb99&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;vxsrin2&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2021-02-02 15:12:45&lt;/sys_updated_on&gt;&lt;/sys_script_include&gt;&lt;/record_update&gt;</payload>
        <payload_hash>-1857242550</payload_hash>
        <record_name>BitSightImportReportProcessor</record_name>
        <reverted_from/>
        <source>1cc2100a1b0aec1046224379b04bcb86</source>
        <source_table>sys_update_set</source_table>
        <state>previous</state>
        <sys_created_by>vxsrin2</sys_created_by>
        <sys_created_on>2021-02-02 15:12:45</sys_created_on>
        <sys_id>8f7b18de1b86a85046224379b04bcb12</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_recorded_at>177634d971d0000001</sys_recorded_at>
        <sys_updated_by>vxsrin2</sys_updated_by>
        <sys_updated_on>2021-02-02 15:12:45</sys_updated_on>
        <type>Script Include</type>
        <update_guid>477b18de0d86a8501217d066c4a48512</update_guid>
        <update_guid_history>477b18de0d86a8501217d066c4a48512:-1857242550,4c600c023d4eac104d683518009106d1:-2111300162</update_guid_history>
    </sys_update_version>
    <sys_metadata_delete action="INSERT_OR_UPDATE">
        <sys_audit_delete/>
        <sys_class_name>sys_metadata_delete</sys_class_name>
        <sys_created_by>vxsrin2</sys_created_by>
        <sys_created_on>2021-02-02 16:17:13</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_db_object display_value="" name="sys_script_include">sys_script_include</sys_db_object>
        <sys_id>1974a7a4c1ca4880aff27e49a7f4e900</sys_id>
        <sys_metadata>2b2084421b4eac1046224379b04bcb99</sys_metadata>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>BitSightImportReportProcessor</sys_name>
        <sys_package display_value="BitSight" source="x_usbna_bs">c8713bfd1b06ac1046224379b04bcb5f</sys_package>
        <sys_parent/>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="BitSight">c8713bfd1b06ac1046224379b04bcb5f</sys_scope>
        <sys_scope_delete display_value="">28242c7df2ad4ff08944b778f3e74100</sys_scope_delete>
        <sys_update_name>sys_script_include_2b2084421b4eac1046224379b04bcb99</sys_update_name>
        <sys_update_version display_value="sys_script_include_2b2084421b4eac1046224379b04bcb99">8f7b18de1b86a85046224379b04bcb12</sys_update_version>
        <sys_updated_by>vxsrin2</sys_updated_by>
        <sys_updated_on>2021-02-02 16:17:13</sys_updated_on>
    </sys_metadata_delete>
</record_update>
